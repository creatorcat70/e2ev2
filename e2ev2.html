<!DOCTYPE html>
<html lang="en">

<head>
	<title>E2Ev3 - Double Ratchet (by cuhassle)</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
			color: #e8f4f8;
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			height: 100vh;
			overflow: hidden;
		}

		#load {
			position: fixed;
			z-index: 99;
			width: 100%;
			height: 100%;
			background: rgba(30, 60, 114, 0.95);
			display: flex;
			align-items: center;
			justify-content: center;
			backdrop-filter: blur(10px);
		}

		#load h1 {
			font-size: 2em;
			animation: pulse 1.5s ease-in-out infinite;
		}

		@keyframes pulse {

			0%,
			100% {
				opacity: 1;
			}

			50% {
				opacity: 0.5;
			}
		}

		#navbar {
			height: 60px;
			width: 100%;
			background: rgba(20, 30, 48, 0.9);
			backdrop-filter: blur(10px);
			display: flex;
			gap: 10px;
			position: fixed;
			padding: 10px 20px;
			box-shadow: 0 2px 20px rgba(0, 0, 0, 0.3);
			z-index: 10;
		}

		button {
			cursor: pointer;
			border: 2px solid transparent;
			border-radius: 8px;
			padding: 8px 16px;
			background: rgba(66, 99, 165, 0.6);
			color: #e8f4f8;
			font-weight: 600;
			transition: all 0.3s ease;
		}

		button:hover {
			background: rgba(66, 99, 165, 0.9);
			border-color: #64b5f6;
			transform: translateY(-2px);
		}

		.navbar-div {
			display: flex;
			gap: 10px;
			background: transparent;
			align-items: center;
		}

		.right {
			margin-left: auto;
		}

		#tabs {
			overflow-x: auto;
			overflow-y: hidden;
			display: flex;
			gap: 5px;
		}

		#tabs::-webkit-scrollbar {
			height: 4px;
		}

		#tabs::-webkit-scrollbar-thumb {
			background: rgba(100, 181, 246, 0.5);
			border-radius: 4px;
		}

		#tabs button {
			white-space: nowrap;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		#tabs button.active {
			background: rgba(100, 181, 246, 0.8);
			border-color: #64b5f6;
		}

		.tab-close {
			background: transparent;
			border: none;
			padding: 0 4px;
			margin-left: 4px;
			color: #ff6b6b;
			font-size: 18px;
		}

		.tab-close:hover {
			transform: scale(1.2);
		}

		main {
			height: calc(100vh - 60px);
			width: 100%;
			padding: 80px 20px 20px;
			overflow-y: auto;
		}

		main::-webkit-scrollbar {
			width: 8px;
		}

		main::-webkit-scrollbar-thumb {
			background: rgba(100, 181, 246, 0.5);
			border-radius: 4px;
		}

		#mainContainer {
			display: none;
			max-width: 1200px;
			margin: 0 auto;
		}

		#mainTitle {
			text-align: center;
			margin-bottom: 30px;
			font-size: 2em;
			text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
		}

		#chatInterface {
			background: rgba(20, 30, 48, 0.7);
			border-radius: 16px;
			padding: 20px;
			margin-bottom: 20px;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
		}

		#messageHistory {
			height: 400px;
			overflow-y: auto;
			margin-bottom: 20px;
			padding: 15px;
			background: rgba(30, 60, 114, 0.4);
			border-radius: 12px;
		}

		#messageHistory::-webkit-scrollbar {
			width: 6px;
		}

		#messageHistory::-webkit-scrollbar-thumb {
			background: rgba(100, 181, 246, 0.5);
			border-radius: 3px;
		}

		.message {
			margin: 10px 0;
			padding: 12px 16px;
			border-radius: 12px;
			max-width: 70%;
			word-wrap: break-word;
			animation: fadeIn 0.3s ease;
		}

		@keyframes fadeIn {
			from {
				opacity: 0;
				transform: translateY(10px);
			}

			to {
				opacity: 1;
				transform: translateY(0);
			}
		}

		.message.sent {
			background: rgba(76, 175, 80, 0.6);
			margin-left: auto;
			text-align: right;
		}

		.message.received {
			background: rgba(66, 99, 165, 0.6);
			margin-right: auto;
		}

		.message-time {
			font-size: 0.75em;
			opacity: 0.7;
			margin-top: 4px;
		}

		.input-group {
			display: flex;
			gap: 10px;
			margin-bottom: 15px;
		}

		textarea,
		input {
			border: 2px solid rgba(100, 181, 246, 0.3);
			background: rgba(20, 30, 48, 0.6);
			color: #e8f4f8;
			width: 100%;
			padding: 12px;
			border-radius: 8px;
			resize: vertical;
			font-family: inherit;
			transition: all 0.3s ease;
		}

		textarea:focus,
		input:focus {
			outline: none;
			border-color: #64b5f6;
			box-shadow: 0 0 10px rgba(100, 181, 246, 0.3);
		}

		textarea {
			min-height: 80px;
		}

		.modal {
			display: none;
			position: fixed;
			z-index: 100;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			overflow: auto;
			background: rgba(0, 0, 0, 0.7);
			backdrop-filter: blur(5px);
		}

		.modal-content {
			background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
			margin: 10% auto;
			padding: 30px;
			width: 90%;
			max-width: 600px;
			border-radius: 16px;
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
			animation: slideDown 0.3s ease;
		}

		@keyframes slideDown {
			from {
				transform: translateY(-50px);
				opacity: 0;
			}

			to {
				transform: translateY(0);
				opacity: 1;
			}
		}

		.close {
			float: right;
			font-size: 32px;
			font-weight: bold;
			cursor: pointer;
			color: #ff6b6b;
			transition: all 0.3s ease;
		}

		.close:hover {
			transform: rotate(90deg);
			color: #ff5252;
		}

		.section-group {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 20px;
			margin-top: 20px;
		}

		.section {
			background: rgba(20, 30, 48, 0.5);
			padding: 20px;
			border-radius: 12px;
		}

		code {
			background: rgba(0, 0, 0, 0.3);
			padding: 10px;
			border-radius: 8px;
			display: block;
			word-wrap: break-word;
			margin-top: 10px;
			font-family: 'Courier New', monospace;
			max-height: 150px;
			overflow-y: auto;
			font-size: 0.85em;
		}

		.status-indicator {
			display: inline-block;
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background: #4caf50;
			margin-left: 8px;
			animation: blink 2s ease infinite;
		}

		@keyframes blink {

			0%,
			100% {
				opacity: 1;
			}

			50% {
				opacity: 0.3;
			}
		}

		@media (max-width: 768px) {
			.section-group {
				grid-template-columns: 1fr;
			}

			.message {
				max-width: 85%;
			}
		}
	</style>
</head>

<body>
	<div id="load">
		<h1>Initializing Encryption...</h1>
	</div>

	<div id="settingsModal" class="modal">
		<div class="modal-content">
			<span class="close" onclick="document.getElementById('settingsModal').style.display = 'none';">&times;</span>
			<h1>‚öôÔ∏è Settings</h1>
			<br>
			<p><strong>Your Public Key:</strong></p>
			<textarea id="viewPublicKey" readonly style="height: 100px;"></textarea>
			<br><br>
			<p><strong>Security Info:</strong></p>
			<p style="opacity: 0.8;">This app uses Double Ratchet algorithm with ECDH (P-521) and AES-GCM encryption for
				forward secrecy.</p>
		</div>
	</div>

	<div id="newTabModal" class="modal">
		<div class="modal-content">
			<span class="close" onclick="closeModal()">&times;</span>
			<h1>üîê Start New Secure Chat</h1>
			<br>
			<p><strong>Contact Name:</strong></p>
			<input id="name-input" placeholder="Enter contact name">
			<br><br>
			<p><strong>Their Public Key:</strong></p>
			<textarea id="key-input" placeholder="Paste their public key here"></textarea>
			<br><br>
			<button id="createChat" onclick="createNewTab()">Create Chat</button>
		</div>
	</div>

	<nav id="navbar">
		<div id="tabs" class="navbar-div"></div>
		<button id="addTab" onclick="openTabModal()">+ New Chat</button>
		<div class="right navbar-div">
			<button id="copyPublicKey" onclick="copyPublicKey()">üìã Copy Public Key</button>
			<button id="settings" onclick="openSettings()">‚öôÔ∏è</button>
		</div>
	</nav>

	<main>
		<div id="mainContainer">
			<h1 id="mainTitle"></h1>

			<div id="chatInterface">
				<h2>üí¨ Conversation <span class="status-indicator"></span></h2>
				<div id="messageHistory"></div>

				<div class="input-group">
					<textarea id="messageInput" placeholder="Type your message..."></textarea>
				</div>
				<button onclick="sendMessage()" style="width: 100%; padding: 12px;">Send Encrypted Message</button>

				<br><br>
				<h3>üì• Receive Message</h3>
				<div class="input-group">
					<textarea id="receiveInput" placeholder="Paste encrypted message here..."></textarea>
				</div>
				<button onclick="receiveMessage()" style="width: 100%; padding: 12px;">Decrypt & Add to History</button>
			</div>

			<div class="section-group">
				<div class="section">
					<h3>üîí Latest Encrypted</h3>
					<code id="encryptedDisplay">Encrypted message will appear here</code>
					<button onclick="copyEncrypted()" style="width: 100%; margin-top: 10px;">Copy Encrypted</button>
				</div>
				<div class="section">
					<h3>üîì Latest Decrypted</h3>
					<code id="decryptedDisplay">Decrypted message will appear here</code>
				</div>
			</div>
		</div>
	</main>

	<script>
		class ChatTab {
			constructor(name, publicKey) {
				this.name = name;
				this.theirPublicKey = publicKey;
				this.messages = [];
				
				// Ratchet state
				this.rootKey = null;
				this.sendChainKey = null;
				this.receiveChainKey = null;
				this.myDHKeyPair = null;
				this.theirDHPublicKey = null;
				this.sendCount = 0;
				this.receiveCount = 0;
				this.prevSendCount = 0;
			}
		}

		let tabs = [];
		let activetab = -1;
		let myIdentityKeyPair = null;
		let myPublicKeyB64 = "";

		function _arrayBufferToBase64(buffer) {
			let binary = '';
			const bytes = new Uint8Array(buffer);
			for (let i = 0; i < bytes.byteLength; i++) {
				binary += String.fromCharCode(bytes[i]);
			}
			return window.btoa(binary);
		}

		function _base64ToArrayBuffer(base64) {
			const binaryString = atob(base64);
			const bytes = new Uint8Array(binaryString.length);
			for (let i = 0; i < binaryString.length; i++) {
				bytes[i] = binaryString.charCodeAt(i);
			}
			return bytes.buffer;
		}

		async function generateKeys() {
			myIdentityKeyPair = await window.crypto.subtle.generateKey(
				{ name: "ECDH", namedCurve: "P-521" },
				true,
				["deriveKey", "deriveBits"]
			);
			const publicKeyRaw = await window.crypto.subtle.exportKey("raw", myIdentityKeyPair.publicKey);
			myPublicKeyB64 = _arrayBufferToBase64(publicKeyRaw);
			document.getElementById('load').style.display = 'none';
		}

		async function HKDF(inputKey, salt, info, length) {
			const key = await window.crypto.subtle.importKey(
				"raw",
				inputKey,
				{ name: "HKDF" },
				false,
				["deriveBits"]
			);
			const bits = await window.crypto.subtle.deriveBits(
				{
					name: "HKDF",
					hash: "SHA-256",
					salt: salt,
					info: new TextEncoder().encode(info)
				},
				key,
				length * 8
			);
			return new Uint8Array(bits);
		}

		async function performDH(privateKey, publicKey) {
			return await window.crypto.subtle.deriveBits(
				{ name: "ECDH", public: publicKey },
				privateKey,
				528
			);
		}

		async function generateDHKeyPair() {
			return await window.crypto.subtle.generateKey(
				{ name: "ECDH", namedCurve: "P-521" },
				true,
				["deriveKey", "deriveBits"]
			);
		}

		async function deriveRootAndChainKeys(rootKey, dhSecret) {
			const derived = await HKDF(new Uint8Array(dhSecret), rootKey, "ratchet", 64);
			return {
				rootKey: derived.slice(0, 32),
				chainKey: derived.slice(32, 64)
			};
		}

		async function deriveMessageKey(chainKey) {
			const derived = await HKDF(chainKey, new Uint8Array(32), "chain", 64);
			return {
				chainKey: derived.slice(0, 32),
				messageKey: derived.slice(32, 64)
			};
		}

		async function initializeChat(tab) {
			// Generate initial DH key pair
			tab.myDHKeyPair = await generateDHKeyPair();
			
			// Compute initial shared secret
			const sharedSecret = await performDH(myIdentityKeyPair.privateKey, tab.theirPublicKey);
			
			// Initialize root key
			tab.rootKey = new Uint8Array(sharedSecret).slice(0, 32);
			
			// Perform initial DH ratchet to get send chain
			const dhSecret = await performDH(tab.myDHKeyPair.privateKey, tab.theirPublicKey);
			const keys = await deriveRootAndChainKeys(tab.rootKey, dhSecret);
			tab.rootKey = keys.rootKey;
			tab.sendChainKey = keys.chainKey;
		}

		async function encryptMessage(tab, plaintext) {
			if (!tab.sendChainKey) {
				throw new Error("Cannot send message yet - wait to receive first message");
			}

			// Derive message key
			const derived = await deriveMessageKey(tab.sendChainKey);
			tab.sendChainKey = derived.chainKey;
			const messageKey = derived.messageKey;

			// Encrypt
			const iv = crypto.getRandomValues(new Uint8Array(12));
			const key = await window.crypto.subtle.importKey(
				"raw",
				messageKey,
				{ name: "AES-GCM" },
				false,
				["encrypt"]
			);

			const ciphertext = await window.crypto.subtle.encrypt(
				{ name: "AES-GCM", iv: iv },
				key,
				new TextEncoder().encode(plaintext)
			);

			// Export current DH public key
			const dhPublicKeyRaw = await window.crypto.subtle.exportKey("raw", tab.myDHKeyPair.publicKey);

			return {
				dh: _arrayBufferToBase64(dhPublicKeyRaw),
				n: tab.sendCount++,
				pn: tab.prevSendCount,
				iv: _arrayBufferToBase64(iv),
				ct: _arrayBufferToBase64(ciphertext)
			};
		}

		async function decryptMessage(tab, message) {
			// Import their DH public key from message
			const theirDHKey = await window.crypto.subtle.importKey(
				"raw",
				_base64ToArrayBuffer(message.dh),
				{ name: "ECDH", namedCurve: "P-521" },
				true,
				[]
			);

			// Check if we need to ratchet
			const theirDHKeyB64 = _arrayBufferToBase64(await window.crypto.subtle.exportKey("raw", theirDHKey));
			const currentDHKeyB64 = tab.theirDHPublicKey 
				? _arrayBufferToBase64(await window.crypto.subtle.exportKey("raw", tab.theirDHPublicKey))
				: null;

			if (!currentDHKeyB64 || currentDHKeyB64 !== theirDHKeyB64) {
				// DH Ratchet step
				tab.theirDHPublicKey = theirDHKey;
				
				// Derive receive chain
				const dhSecret1 = await performDH(tab.myDHKeyPair.privateKey, theirDHKey);
				const keys1 = await deriveRootAndChainKeys(tab.rootKey, dhSecret1);
				tab.rootKey = keys1.rootKey;
				tab.receiveChainKey = keys1.chainKey;
				tab.receiveCount = 0;

				// Generate new DH key pair and derive send chain
				tab.prevSendCount = tab.sendCount;
				tab.sendCount = 0;
				tab.myDHKeyPair = await generateDHKeyPair();
				
				const dhSecret2 = await performDH(tab.myDHKeyPair.privateKey, theirDHKey);
				const keys2 = await deriveRootAndChainKeys(tab.rootKey, dhSecret2);
				tab.rootKey = keys2.rootKey;
				tab.sendChainKey = keys2.chainKey;
			}

			// Derive message key
			const derived = await deriveMessageKey(tab.receiveChainKey);
			tab.receiveChainKey = derived.chainKey;
			const messageKey = derived.messageKey;
			tab.receiveCount++;

			// Decrypt
			const key = await window.crypto.subtle.importKey(
				"raw",
				messageKey,
				{ name: "AES-GCM" },
				false,
				["decrypt"]
			);

			const plaintext = await window.crypto.subtle.decrypt(
				{ name: "AES-GCM", iv: _base64ToArrayBuffer(message.iv) },
				key,
				_base64ToArrayBuffer(message.ct)
			);

			return new TextDecoder().decode(plaintext);
		}

		function copyPublicKey() {
			const btn = document.getElementById("copyPublicKey");
			if (navigator.clipboard) {
				navigator.clipboard.writeText(myPublicKeyB64).then(() => {
					btn.innerText = "‚úÖ Copied!";
					setTimeout(() => { btn.innerText = "üìã Copy Public Key"; }, 1500);
				});
			}
		}

		function openSettings() {
			document.getElementById('viewPublicKey').value = myPublicKeyB64;
			document.getElementById('settingsModal').style.display = 'block';
		}

		async function createNewTab() {
			const nameInput = document.getElementById("name-input");
			const keyInputValue = document.getElementById("key-input").value.trim();

			if (!keyInputValue) {
				alert("Please enter a public key");
				return;
			}

			try {
				const otherPublicKey = await window.crypto.subtle.importKey(
					"raw",
					_base64ToArrayBuffer(keyInputValue),
					{ name: "ECDH", namedCurve: "P-521" },
					true,
					[]
				);

				const name = nameInput.value.trim() || `Contact ${tabs.length + 1}`;
				const newTab = new ChatTab(name, otherPublicKey);
				tabs.push(newTab);
				activetab = tabs.length - 1;

				await initializeChat(newTab);

				const tabButton = document.createElement("button");
				const tabIndex = activetab;
				tabButton.innerHTML = `${name} <span class="tab-close" onclick="event.stopPropagation(); closeTab(${tabIndex});">&times;</span>`;
				tabButton.onclick = () => openTab(tabIndex);
				document.getElementById("tabs").appendChild(tabButton);

				closeModal();
				openTab(activetab);
			} catch (e) {
				console.error(e);
				alert("Invalid public key format");
			}
		}

		function openTab(index) {
			activetab = index;
			document.querySelectorAll('#tabs button').forEach((btn, i) => {
				btn.classList.toggle('active', i === index);
			});

			const tab = tabs[index];
			document.getElementById("mainTitle").innerText = `üîê ${tab.name}`;
			document.getElementById("mainContainer").style.display = "block";
			document.getElementById("messageInput").value = "";
			document.getElementById("receiveInput").value = "";
			renderMessages();
		}

		function renderMessages() {
			const history = document.getElementById("messageHistory");
			history.innerHTML = "";

			tabs[activetab].messages.forEach(msg => {
				const div = document.createElement("div");
				div.className = `message ${msg.type}`;
				div.innerHTML = `
                    <div>${msg.text}</div>
                    <div class="message-time">${msg.time}</div>
                `;
				history.appendChild(div);
			});

			history.scrollTop = history.scrollHeight;
		}

		async function sendMessage() {
			if (activetab < 0) return;

			const input = document.getElementById("messageInput");
			const text = input.value.trim();
			if (!text) return;

			try {
				const tab = tabs[activetab];
				const encrypted = await encryptMessage(tab, text);
				const fullMessage = JSON.stringify(encrypted);

				document.getElementById("encryptedDisplay").innerText = fullMessage;

				tab.messages.push({
					type: "sent",
					text: text,
					time: new Date().toLocaleTimeString()
				});

				input.value = "";
				renderMessages();
			} catch (e) {
				console.error("Encryption error:", e);
				alert("Failed to encrypt: " + e.message);
			}
		}

		async function receiveMessage() {
			if (activetab < 0) return;

			const input = document.getElementById("receiveInput");
			const encryptedText = input.value.trim();
			if (!encryptedText) return;

			try {
				const message = JSON.parse(encryptedText);
				const tab = tabs[activetab];

				const decryptedText = await decryptMessage(tab, message);
				document.getElementById("decryptedDisplay").innerText = decryptedText;

				tab.messages.push({
					type: "received",
					text: decryptedText,
					time: new Date().toLocaleTimeString()
				});

				input.value = "";
				renderMessages();
			} catch (e) {
				console.error("Decryption error:", e);
				alert("Failed to decrypt: " + e.message);
			}
		}

		function copyEncrypted() {
			const text = document.getElementById("encryptedDisplay").innerText;
			if (text && navigator.clipboard) {
				navigator.clipboard.writeText(text);
			}
		}

		function openTabModal() {
			document.getElementById("newTabModal").style.display = "block";
		}

		function closeModal() {
			document.getElementById("newTabModal").style.display = "none";
			document.getElementById("name-input").value = "";
			document.getElementById("key-input").value = "";
		}

		function closeTab(index) {
			if (confirm(`Close chat with ${tabs[index].name}?`)) {
				tabs.splice(index, 1);
				const tabButtons = document.querySelectorAll('#tabs button');
				tabButtons[index].remove();

				if (activetab === index) {
					activetab = -1;
					document.getElementById("mainContainer").style.display = "none";
				} else if (activetab > index) {
					activetab--;
				}
			}
		}

		window.addEventListener("beforeunload", (e) => {
			if (tabs.length > 0) {
				e.returnValue = "Your chats and keys will be lost if you close this page.";
				return e.returnValue;
			}
		});

		window.onload = generateKeys;
	</script>
</body>

</html>
